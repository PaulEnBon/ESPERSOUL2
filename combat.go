package main

import (
	"fmt"
	"math/rand"
	"strings"
	"time"

	"github.com/eiannone/keyboard"
)

// Emoji par classe d'ennemi (affich√© dans l'intro du combat)
func emojiForEnemyName(name string) string {
	switch name {
	case "Rat":
		return "üêÄ"
	case "Gel√©e":
		return "üü¢"
	case "Brigand":
		return "üó°Ô∏è"
	case "Archer":
		return "üèπ"
	case "Apprenti Pyro":
		return "üî•"
	case "Chevalier":
		return "üõ°Ô∏è"
	case "Berserker":
		return "‚öîÔ∏è"
	case "Mage Sombre":
		return "ü™Ñ"
	case "Seigneur D√©mon":
		return "üëø"
	case "Archimage":
		return "üìú"
	case "Champion d√©chu":
		return "ü•∑"
	case "Mentor Maudit":
		return "üßô"
	case "Mentor Supr√™me":
		return "üéì"
	default:
		return "üëæ"
	}
}

// ---- R√©compenses configurables ----
// Peut √™tre d√©plac√© dans un fichier de config plus tard.
const (
	baseMinCoins         = 5    // ancien 3
	baseMaxCoins         = 9    // g√©n√®re range baseMin..baseMax inclus
	legendaryWeaponBonus = 0.50 // +50% si arme l√©gendaire
	puffAttackBonusShare = 0.20 // 20% de l'attackBoost converti en bonus or (ex: 30% atk -> +6% or)
	jackpotChancePercent = 6    // % de chance de jackpot
	jackpotMultiplier    = 4.0  // x4 sur le total final
)

// calcule le loot de pi√®ces enrichi
func computeCoinLoot() (coins int, jackpot bool, breakdown string) {
	// Base al√©atoire
	base := baseMinCoins + rand.Intn(baseMaxCoins-baseMinCoins+1)

	// Bonus arme l√©gendaire
	legendaryBonus := 0
	if playerStats.hasLegendaryWeapon {
		legendaryBonus = int(float64(base) * legendaryWeaponBonus)
	}

	// Bonus Puff converti (attackBoost est un pourcentage cumulatif)
	puffBonus := int(float64(base) * (float64(playerStats.attackBoost) / 100.0) * puffAttackBonusShare)

	total := base + legendaryBonus + puffBonus

	// Jackpot ?
	if rand.Intn(100) < jackpotChancePercent {
		total = int(float64(total) * jackpotMultiplier)
		return total, true, fmt.Sprintf("base=%d +legend=%d +puff=%d xJackpot(%.1fx)", base, legendaryBonus, puffBonus, jackpotMultiplier)
	}

	return total, false, fmt.Sprintf("base=%d +legend=%d +puff=%d", base, legendaryBonus, puffBonus)
}

// centralise l'affichage de la r√©compense en pi√®ces pour √©viter les doublons
func printCoinReward(coins int, jackpot bool) {
	if jackpot {
		fmt.Printf("üíé JACKPOT ! Vous obtenez %d pi√®ces !\n", coins)
	} else {
		fmt.Printf("‚ú® Vous avez re√ßu %d pi√®ces.\n", coins)
	}
}

// (emojiForEnemyName restaur√© ici)

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
// Syst√®me de combat int√©grant classes/armes/d√©g√¢ts/effets/artefacts
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

// fabrique un personnage joueur de base (en attendant la vraie s√©lection)
func buildPlayerCharacter() Personnage {
	// Part d'une copie du joueur persistant
	p := currentPlayer
	// Applique l'armure et l'arme sur la copie (pas sur l'√©tat persistant)
	_ = EquiperArmure(&p, p.ArmuresDisponibles)
	if p.NiveauArme >= 0 && p.NiveauArme < len(p.ArmesDisponibles) {
		_ = EquiperArme(&p, p.ArmesDisponibles[p.NiveauArme])
	}
	// Pr√©serve les PV persistants et les borne au nouveau PVMax
	if currentPlayer.PV > 0 {
		if currentPlayer.PV > p.PVMax {
			p.PV = p.PVMax
		} else {
			p.PV = currentPlayer.PV
		}
	} else {
		// Si PV persistants √† 0, d√©marre √† 0 (pas de heal auto)
		if p.PV > p.PVMax {
			p.PV = p.PVMax
		}
	}
	return p
}

// r√©alise une attaque avec calcul pr√©cision/crit/type en utilisant les helpers de degats.go
func resolveAttack(attaquant, defenseur *Personnage, degatsBase int, typeAttaque string) (degats int, touche bool, crit bool) {
	d, estCrit, aTouche := CalculerDegatsAvecCritique(attaquant, defenseur, degatsBase, typeAttaque)
	return d, aTouche, estCrit
}

// choisit une comp√©tence ¬´ simple ¬ª (priorit√© aux d√©g√¢ts > 0) sur l'arme √©quip√©e
func pickCompetence(p *Personnage) (Competence, bool) {
	if len(p.ArmeEquipee.Competences) == 0 {
		return Competence{}, false
	}
	// Choisit la premi√®re comp√©tence avec d√©g√¢ts positifs, sinon la premi√®re dispo
	for _, c := range p.ArmeEquipee.Competences {
		if c.Degats > 0 {
			return c, true
		}
	}
	return p.ArmeEquipee.Competences[0], true
}

// S√©lection al√©atoire d'une comp√©tence pour l'IA ennemie
//   - 70%: privil√©gie une comp√©tence avec d√©g√¢ts (>0) si disponible
//   - 30%: choix totalement al√©atoire (utilitaire/buff compris)
func pickRandomCompetence(p *Personnage) (Competence, bool) {
	comps := p.ArmeEquipee.Competences
	if len(comps) == 0 {
		return Competence{}, false
	}
	offensives := make([]Competence, 0, len(comps))
	for _, c := range comps {
		if c.Degats > 0 {
			offensives = append(offensives, c)
		}
	}
	if len(offensives) > 0 && rand.Intn(100) < 70 {
		return offensives[rand.Intn(len(offensives))], true
	}
	return comps[rand.Intn(len(comps))], true
}

// applique un effet √©ventuel sur la cible en fonction de la comp√©tence
func maybeApplyEffect(defenseur *Personnage, comp Competence) {
	if comp.TypeEffet == "" {
		return
	}
	if eff := CreerEffet(comp.TypeEffet, comp.Puissance); eff != nil {
		AppliquerEffet(defenseur, *eff)
	}
}

// d√©termine si l'effet est plut√¥t un buff sur soi que sur la cible
func isSelfBuff(effectName string) bool {
	switch effectName {
	case "Augmentation de D√©g√¢ts", "Augmentation de D√©g√¢ts Magiques", "R√©g√©n√©ration", "Gu√©rison Poison":
		return true
	default:
		return false
	}
}

// propose la liste des comp√©tences de l'arme et retourne le choix de l'utilisateur
func chooseCompetence(p *Personnage) (Competence, bool, bool) {
	comps := p.ArmeEquipee.Competences
	if len(comps) == 0 {
		return Competence{}, false, false
	}
	fmt.Println("\nChoisissez une comp√©tence:")
	for i, c := range comps {
		eff := c.TypeEffet
		extra := ""
		if eff != "" {
			extra = fmt.Sprintf(" | Effet: %s (puiss.%d)", eff, c.Puissance)
		}
		fmt.Printf("  %d) %s [%s] D√©g√¢ts:%d%s\n", i+1, c.Nom, c.Type, c.Degats, extra)
	}
	fmt.Println("  R) Retour")
	fmt.Print("Votre choix (1-", len(comps), " ou R): ")
	// Lire une seule touche depuis le canal global
	if globalKeyEvents == nil {
		// Fallback extr√™me si le canal n'est pas pr√™t
		return comps[0], true, false
	}
	e := <-globalKeyEvents
	if e.Key == keyboard.KeyEsc {
		return Competence{}, false, true
	}
	r := e.Rune
	if r == 'r' || r == 'R' {
		return Competence{}, false, true
	}
	if r >= '1' && r <= '9' {
		idx := int(r - '0')
		if idx >= 1 && idx <= len(comps) {
			return comps[idx-1], true, false
		}
	}
	fmt.Println("Saisie invalide, comp√©tence par d√©faut utilis√©e.")
	return comps[0], true, false
}

// Sous-menu Objets (potion, Puff 9K, etc.) ‚Äî n'utilise pas le tour
// Retourne true si le joueur meurt pendant l'utilisation (ex: Puff 9K)
func objectMenu(player, enemy *Personnage) bool {
	for {
		fmt.Println("\nüéí Objets:")
		// Soins
		fmt.Printf("  1) Potion (x%d) ‚Äî +70 PV\n", playerInventory["potions"])
		fmt.Printf("  2) Potion Mineure (x%d) ‚Äî soin l√©ger\n", playerInventory["potion_mineure"])
		fmt.Printf("  3) Potion Majeure (x%d) ‚Äî soin puissant\n", playerInventory["potion_majeure"])
		fmt.Printf("  4) Potion Supr√™me (x%d) ‚Äî soin massif\n", playerInventory["potion_supreme"])
		fmt.Printf("  5) Antidote (x%d) ‚Äî retire poison\n", playerInventory["antidote"])
		fmt.Printf("  V) Vodka de Vitaly (x%d) ‚Äî r√©g√©n√®re toute la vie !\n", playerInventory["vodka_vitaly"])
		// Buffs
		fmt.Printf("  6) Puff 9K (x%d) ‚Äî +15%%%% d√©g√¢ts (loot) + buff, -5 PV\n", playerInventory["puff_9k"])
		fmt.Printf("  7) √âlixir de Force (x%d) ‚Äî buff d√©g√¢ts\n", playerInventory["elixir_force"])
		fmt.Printf("  8) √âlixir de Vitesse (x%d) ‚Äî buff d√©g√¢ts magiques\n", playerInventory["elixir_vitesse"])
		fmt.Printf("  9) √âlixir de Pr√©cision (x%d) ‚Äî buff d√©g√¢ts/crit\n", playerInventory["elixir_critique"])
		// Offensifs/Utilitaires
		fmt.Printf("  A) Potion de D√©g√¢ts (x%d) ‚Äî d√©g√¢ts magiques\n", playerInventory["potion_degats"])
		fmt.Printf("  B) Bombe Incendiaire (x%d) ‚Äî d√©g√¢ts + br√ªlure\n", playerInventory["bombe_incendiaire"])
		fmt.Printf("  C) Bombe Givrante (x%d) ‚Äî d√©g√¢ts + √©tourdissement\n", playerInventory["bombe_givrante"])
		fmt.Printf("  D) Grenade Fumig√®ne (x%d) ‚Äî n√©bulation (aveugle)\n", playerInventory["grenade_fumigene"])
		fmt.Printf("  E) Parchemin de Dispersion (x%d) ‚Äî affaiblissement\n", playerInventory["parchemin_dispersion"])
		fmt.Println("  [R]etour")
		fmt.Print("Votre choix: ")
		if globalKeyEvents == nil {
			return false
		}
		e := <-globalKeyEvents
		input := strings.ToLower(string(e.Rune))
		if e.Key == keyboard.KeyEsc {
			input = "r"
		}
		switch input {
		case "v": // Vodka de Vitaly ‚Äî r√©g√©n√®re toute la vie
			if playerInventory["vodka_vitaly"] > 0 {
				heal := player.PVMax - player.PV
				player.PV = player.PVMax
				playerInventory["vodka_vitaly"]--
				// Applique le malus d'ivresse (-30% pr√©cision pendant 3 tours)
				if eff := CreerEffet("Ivresse", 0); eff != nil {
					AppliquerEffet(player, *eff)
				}
				fmt.Printf("üç∂ Vodka de Vitaly: +%d PV (PV: %d/%d) ‚Äî Toute votre vie est r√©g√©n√©r√©e, mais votre pr√©cision chute temporairement !\n", heal, player.PV, player.PVMax)
			} else {
				fmt.Println("‚ùå Vous n'avez pas de Vodka de Vitaly !")
			}
		case "1": // Potion simple +70 PV (compat historique)
			if playerInventory["potions"] > 0 {
				heal := 70
				player.PV += heal
				if player.PV > player.PVMax {
					player.PV = player.PVMax
				}
				playerInventory["potions"]--
				fmt.Printf("üß™ Potion: +%d PV (PV: %d/%d)\n", heal, player.PV, player.PVMax)
			} else {
				fmt.Println("‚ùå Vous n'avez pas de potion !")
			}
		case "2": // Potion Mineure
			if playerInventory["potion_mineure"] > 0 {
				comp := potionMineure.Competences[0]
				heal := -comp.Degats
				if heal < 0 {
					heal = 30
				}
				player.PV += heal
				if player.PV > player.PVMax {
					player.PV = player.PVMax
				}
				playerInventory["potion_mineure"]--
				fmt.Printf("üß™ Potion mineure: +%d PV (PV: %d/%d)\n", heal, player.PV, player.PVMax)
			} else {
				fmt.Println("‚ùå Vous n'avez pas de potion mineure !")
			}
		case "3": // Potion Majeure
			if playerInventory["potion_majeure"] > 0 {
				comp := potionMajeure.Competences[0]
				heal := -comp.Degats
				if heal < 0 {
					heal = 80
				}
				player.PV += heal
				if player.PV > player.PVMax {
					player.PV = player.PVMax
				}
				playerInventory["potion_majeure"]--
				fmt.Printf("üß™ Potion majeure: +%d PV (PV: %d/%d)\n", heal, player.PV, player.PVMax)
			} else {
				fmt.Println("‚ùå Vous n'avez pas de potion majeure !")
			}
		case "4": // Potion Supr√™me
			if playerInventory["potion_supreme"] > 0 {
				comp := potionSupreme.Competences[0]
				heal := -comp.Degats
				if heal < 0 {
					heal = 200
				}
				player.PV += heal
				if player.PV > player.PVMax {
					player.PV = player.PVMax
				}
				playerInventory["potion_supreme"]--
				fmt.Printf("üß™ Potion supr√™me: +%d PV (PV: %d/%d)\n", heal, player.PV, player.PVMax)
			} else {
				fmt.Println("‚ùå Vous n'avez pas de potion supr√™me !")
			}
		case "5": // Antidote
			if playerInventory["antidote"] > 0 {
				if eff := CreerEffet("Gu√©rison Poison", 1); eff != nil {
					AppliquerEffet(player, *eff)
				}
				playerInventory["antidote"]--
				fmt.Println("üßØ Antidote utilis√©: le poison est dissip√©.")
			} else {
				fmt.Println("‚ùå Vous n'avez pas d'antidote !")
			}
		case "6": // Puff 9K
			if playerInventory["puff_9k"] > 0 {
				playerInventory["puff_9k"]--
				playerStats.attackBoost += 15 // bonus de loot cumulatif
				if eff := CreerEffet("Augmentation de D√©g√¢ts", 2); eff != nil {
					AppliquerEffet(player, *eff)
				}
				player.PV -= 5
				if player.PV < 0 {
					player.PV = 0
				}
				fmt.Println("üíä Vous utilisez un Puff 9K !")
				fmt.Println("‚ö° +15% de d√©g√¢ts (loot) et buff de d√©g√¢ts temporaire !")
				fmt.Printf("üíî Vous perdez 5 PV. PV actuels: %d/%d\n", player.PV, player.PVMax)
				if player.PV <= 0 {
					fmt.Println("üíÄ Le Puff 9K vous a tu√© ! Attention √† la surdose...")
					return true
				}
			} else {
				fmt.Println("‚ùå Vous n'avez pas de Puff 9K !")
			}
		case "7": // √âlixir de Force
			if playerInventory["elixir_force"] > 0 {
				if eff := CreerEffet("Augmentation de D√©g√¢ts", 4); eff != nil {
					AppliquerEffet(player, *eff)
				}
				playerInventory["elixir_force"]--
				fmt.Println("üßÉ √âlixir de Force: vos d√©g√¢ts sont augment√©s !")
			} else {
				fmt.Println("‚ùå Vous n'avez pas d'√©lixir de force !")
			}
		case "8": // √âlixir de Vitesse
			if playerInventory["elixir_vitesse"] > 0 {
				if eff := CreerEffet("Augmentation de D√©g√¢ts Magiques", 3); eff != nil {
					AppliquerEffet(player, *eff)
				}
				playerInventory["elixir_vitesse"]--
				fmt.Println("üßÉ √âlixir de Vitesse: vos d√©g√¢ts magiques sont augment√©s !")
			} else {
				fmt.Println("‚ùå Vous n'avez pas d'√©lixir de vitesse !")
			}
		case "9": // √âlixir de Pr√©cision
			if playerInventory["elixir_critique"] > 0 {
				if eff := CreerEffet("Augmentation de D√©g√¢ts", 5); eff != nil {
					AppliquerEffet(player, *eff)
				}
				playerInventory["elixir_critique"]--
				fmt.Println("üßÉ √âlixir de Pr√©cision: vos coups deviennent plus meurtriers !")
			} else {
				fmt.Println("‚ùå Vous n'avez pas d'√©lixir de pr√©cision !")
			}
		case "a": // Potion de D√©g√¢ts (attaque magique directe)
			if playerInventory["potion_degats"] > 0 {
				comp := potionDegats.Competences[0]
				dmg, touche, crit := resolveAttack(player, enemy, comp.Degats, comp.Type)
				if !touche {
					fmt.Println("üôÉ Votre lancer de potion rate !")
				} else {
					enemy.PV -= dmg
					if enemy.PV < 0 {
						enemy.PV = 0
					}
					if crit {
						fmt.Printf("üí• Potion de d√©g√¢ts critique ! %d d√©g√¢ts.\n", dmg)
					} else {
						fmt.Printf("üí• Potion de d√©g√¢ts inflige %d d√©g√¢ts.\n", dmg)
					}
				}
				playerInventory["potion_degats"]--
			} else {
				fmt.Println("‚ùå Vous n'avez pas de potion de d√©g√¢ts !")
			}
		case "b": // Bombe Incendiaire
			if playerInventory["bombe_incendiaire"] > 0 {
				comp := bombeIncendiaire.Competences[0]
				dmg, touche, crit := resolveAttack(player, enemy, comp.Degats, comp.Type)
				if !touche {
					fmt.Println("üß® La bombe incendiaire n'atteint pas sa cible !")
				} else {
					enemy.PV -= dmg
					if enemy.PV < 0 {
						enemy.PV = 0
					}
					if crit {
						fmt.Printf("üî• Explosion critique ! %d d√©g√¢ts.\n", dmg)
					} else {
						fmt.Printf("üî• Explosion de feu: %d d√©g√¢ts.\n", dmg)
					}
					if eff := CreerEffet("Br√ªlure", comp.Puissance); eff != nil {
						AppliquerEffet(enemy, *eff)
					}
				}
				playerInventory["bombe_incendiaire"]--
			} else {
				fmt.Println("‚ùå Vous n'avez pas de bombe incendiaire !")
			}
		case "c": // Bombe Givrante
			if playerInventory["bombe_givrante"] > 0 {
				comp := bombeGivrante.Competences[0]
				dmg, touche, crit := resolveAttack(player, enemy, comp.Degats, comp.Type)
				if !touche {
					fmt.Println("‚ùÑÔ∏è La bombe givrante rate sa cible !")
				} else {
					enemy.PV -= dmg
					if enemy.PV < 0 {
						enemy.PV = 0
					}
					if crit {
						fmt.Printf("‚ùÑÔ∏è Explosion glaciale critique ! %d d√©g√¢ts.\n", dmg)
					} else {
						fmt.Printf("‚ùÑÔ∏è Explosion de glace: %d d√©g√¢ts.\n", dmg)
					}
					if eff := CreerEffet("√âtourdissement", comp.Puissance); eff != nil {
						AppliquerEffet(enemy, *eff)
					}
				}
				playerInventory["bombe_givrante"]--
			} else {
				fmt.Println("‚ùå Vous n'avez pas de bombe givrante !")
			}
		case "d": // Grenade Fumig√®ne
			if playerInventory["grenade_fumigene"] > 0 {
				if eff := CreerEffet("N√©bulation", 3); eff != nil {
					AppliquerEffet(enemy, *eff)
				}
				playerInventory["grenade_fumigene"]--
				fmt.Println("üå´Ô∏è Grenade fumig√®ne: l'ennemi voit mal !")
			} else {
				fmt.Println("‚ùå Vous n'avez pas de grenade fumig√®ne !")
			}
		case "e": // Parchemin de Dispersion
			if playerInventory["parchemin_dispersion"] > 0 {
				if eff := CreerEffet("Affaiblissement", 2); eff != nil {
					AppliquerEffet(enemy, *eff)
				}
				playerInventory["parchemin_dispersion"]--
				fmt.Println("üìú Parchemin de Dispersion: l'ennemi est affaibli !")
			} else {
				fmt.Println("‚ùå Vous n'avez pas de parchemin de dispersion !")
			}
		case "r":
			return false
		default:
			fmt.Println("Choix invalide.")
		}
	}
}

// Syst√®me de combat am√©lior√© avec les modules existants
func combat(currentMap string, isSuper bool) interface{} {
	rand.Seed(time.Now().UnixNano())

	// Cr√©e les entit√©s combat
	player := buildPlayerCharacter()
	enemy := CreateRandomEnemyForMap(currentMap, isSuper)

	// Boss final personnalis√© pour salle15
	if currentMap == "salle15" {
		// D√©finition explicite du boss final (ignorer le scaling g√©n√©rique ensuite)
		custom := Personnage{
			Nom:                "Mia Khalifa",
			PV:                 69,
			PVMax:              69,
			Armure:             69,
			ResistMag:          69,
			Precision:          0.90,
			TauxCritique:       0.69,
			MultiplicateurCrit: 1.8,
		}
		// √âquipe l'arme foutre de Zeus
		_ = EquiperArme(&custom, foutreDeZeus)
		// Ajuste les d√©g√¢ts pour refl√©ter "69 attaque"
		custom.ArmeEquipee.DegatsPhysiques = 69
		custom.ArmeEquipee.DegatsMagiques = 69
		enemy = custom
	}

	// Scaling suppl√©mentaire pour salles boss progressives
	levelMultiplier := 1.0
	switch currentMap {
	case "salle12":
		levelMultiplier = 1.2 // Niveau 1/4
	case "salle13":
		levelMultiplier = 1.5 // Niveau 2/4
	case "salle14":
		levelMultiplier = 1.9 // Niveau 3/4
	case "salle15":
		// Pas de scaling : boss d√©j√† d√©fini avec ses stats personnalis√©es
		levelMultiplier = 1.0
	}
	if levelMultiplier > 1.0 {
		enemy.PV = int(float64(enemy.PV) * levelMultiplier)
		enemy.PVMax = int(float64(enemy.PVMax) * levelMultiplier)
		// Buff d√©g√¢ts via augmentation base d√©g√¢ts arme
		if enemy.ArmeEquipee.Nom != "" {
			enemy.ArmeEquipee.DegatsPhysiques = int(float64(enemy.ArmeEquipee.DegatsPhysiques) * (0.85 + levelMultiplier/1.5))
		}
		// L√©g√®re hausse critique
		enemy.TauxCritique += 0.03 * (levelMultiplier - 1)
		if enemy.TauxCritique > 0.60 {
			enemy.TauxCritique = 0.60
		}
	}
	enemyAttackBase := enemy.ArmeEquipee.DegatsPhysiques
	if enemyAttackBase <= 0 {
		enemyAttackBase = 12
	}

	fmt.Println("\nüó°Ô∏è  COMBAT ENGAG√â ! üó°Ô∏è")
	enemyEmoji := emojiForEnemyName(enemy.Nom)
	if isSuper {
		fmt.Printf("Vous affrontez %s %s (SURPUISSANT)\n", enemyEmoji, enemy.Nom)
	} else {
		fmt.Printf("Vous affrontez %s %s\n", enemyEmoji, enemy.Nom)
	}

	for player.PV > 0 && enemy.PV > 0 {
		fmt.Printf("\nüíö Vos PV: %d/%d | üíÄ PV Ennemi: %d/%d\n", player.PV, player.PVMax, enemy.PV, enemy.PVMax)
		if playerStats.hasLegendaryWeapon {
			fmt.Println("üåü Excalibur √©quip√©e (+50% d√©g√¢ts de loot)")
		}

		// Affichage des actions (Objets via sous-menu)
		fmt.Println("Actions: [A]ttaquer, [O]bjet, [F]uir")
		fmt.Print("Choisissez une action: ")
		// Utilise le m√™me canal que la boucle de jeu
		if globalKeyEvents == nil {
			fmt.Println("(clavier non initialis√©)")
			return false
		}
		e := <-globalKeyEvents
		input := strings.ToLower(string(e.Rune))
		if e.Key == keyboard.KeyEsc {
			input = "f"
		}

		// D√©but de tour: protections d'artefacts √©ventuelles
		AppliquerProtectionsArtefactsDebutTour(&player)

		switch input {
		case "a":
			// S√©lection de comp√©tence
			comp, ok, back := chooseCompetence(&player)
			if back {
				// Retour au menu principal sans consommer le tour
				continue
			}
			if !ok {
				// Fallback absolument minimal
				comp = Competence{Nom: "Attaque", Degats: 15, Type: "physique"}
			}

			// Buffs/soins auto-cibl√©s
			if comp.Degats <= 0 && comp.TypeEffet != "" && isSelfBuff(comp.TypeEffet) {
				if eff := CreerEffet(comp.TypeEffet, comp.Puissance); eff != nil {
					AppliquerEffet(&player, *eff)
					fmt.Printf("‚ú® Vous utilisez %s sur vous-m√™me.\n", comp.Nom)
				}
			} else if comp.Degats <= 0 && comp.TypeEffet != "" {
				// Utilitaires offensifs sans d√©g√¢ts (d√©buffs)
				if eff := CreerEffet(comp.TypeEffet, comp.Puissance); eff != nil {
					AppliquerEffet(&enemy, *eff)
					fmt.Printf("‚ú® Vous appliquez %s √† l'ennemi.\n", comp.Nom)
				}
			} else {
				// Attaque avec d√©g√¢ts
				degatsBase := comp.Degats
				typeAtk := comp.Type
				if degatsBase <= 0 {
					degatsBase = 15
				}
				if typeAtk == "" {
					typeAtk = "physique"
				}

				dmg, touche, crit := resolveAttack(&player, &enemy, degatsBase, typeAtk)
				if !touche {
					fmt.Println("üôÉ Votre attaque rate sa cible !")
				} else {
					enemy.PV -= dmg
					if enemy.PV < 0 {
						enemy.PV = 0
					}
					if crit {
						fmt.Printf("‚öîÔ∏è  Coup critique ! Vous infligez %d d√©g√¢ts.\n", dmg)
					} else {
						fmt.Printf("‚öîÔ∏è  Vous infligez %d d√©g√¢ts.\n", dmg)
					}
					if comp.TypeEffet != "" {
						maybeApplyEffect(&enemy, comp)
					}
				}
			}

		case "o":
			// Sous-menu objets: n'utilise pas le tour
			if died := objectMenu(&player, &enemy); died {
				// Persiste la mort imm√©diate
				currentPlayer.PV = player.PV
				playerStats.attackBoost = 0
				return false
			}
			// Si l'objet a tu√© l'ennemi, accorder la victoire imm√©diatement
			if enemy.PV <= 0 {
				fmt.Println("\nüéâ VICTOIRE ! Vous avez vaincu la cr√©ature !")
				playerStats.enemiesKilled++
				coins, jackpot, _ := computeCoinLoot()
				addToInventory("pi√®ces", coins)
				printCoinReward(coins, jackpot)
				tier := tierForMap(currentMap)
				rocks := 0
				switch tier {
				case TierTutorial, TierEarly:
					rocks = 1
				case TierMid:
					rocks = 2
				case TierLate:
					rocks = 3
				}
				if rocks > 0 {
					currentPlayer.Roches += rocks
					fmt.Printf("ü™® Vous obtenez %d roche(s) d'√©volution. Total roches: %d\n", rocks, currentPlayer.Roches)
				}
				currentPlayer.PV = player.PV
				playerStats.attackBoost = 0
				fmt.Println("üí® La cr√©ature dispara√Æt compl√®tement dans un nuage de fum√©e...")
				return "disappear"
			}
			// Sinon, ne consomme pas le tour ennemi
			continue

		case "f":
			fmt.Println("üí® Vous fuyez le combat !")
			// Persiste les PV du joueur
			currentPlayer.PV = player.PV
			// Reset les bonus temporaires c√¥t√© anciens stats loot
			playerStats.attackBoost = 0
			return false

		default:
			fmt.Println("Action invalide !")
			// on passe quand m√™me au tour adverse, comme avant
		}

		// Fin d'action joueur: traitements d'effets sur les deux
		TraiterEffetsFinTour(&player)
		TraiterEffetsFinTour(&enemy)

		if enemy.PV <= 0 {
			fmt.Println("\nüéâ VICTOIRE ! Vous avez vaincu la cr√©ature !")

			// Incr√©mente le compteur d'ennemis tu√©s (stat h√©rit√©e)
			playerStats.enemiesKilled++

			coins, jackpot, _ := computeCoinLoot()
			addToInventory("pi√®ces", coins)
			printCoinReward(coins, jackpot)

			// Drop de roches d'√©volution selon la difficult√©
			tier := tierForMap(currentMap)
			rocks := 0
			switch tier {
			case TierTutorial, TierEarly:
				rocks = 1 // easy
			case TierMid:
				rocks = 2 // moyen
			case TierLate:
				rocks = 3 // hard
			}
			if rocks > 0 {
				currentPlayer.Roches += rocks
				fmt.Printf("ü™® Vous obtenez %d roche(s) d'√©volution. Total roches: %d\n", rocks, currentPlayer.Roches)
			}

			// Persiste les PV du joueur
			currentPlayer.PV = player.PV
			// Reset bonus temporaires h√©rit√©s
			playerStats.attackBoost = 0

			// Tous les ennemis disparaissent (PNJ g√©r√© c√¥t√© loop pour le cas sp√©cial)
			fmt.Println("üí® La cr√©ature dispara√Æt compl√®tement dans un nuage de fum√©e...")
			return "disappear"
		}

		// Tour de l'ennemi ‚Äî saute si √©tourdi
		if EstEtourdi(&enemy) {
			fmt.Println("üòµ‚Äçüí´ L'ennemi est √©tourdi et rate son tour !")
		} else {
			// L'ennemi choisit une comp√©tence au hasard (biais offensif)
			ecomp, ok := pickRandomCompetence(&enemy)
			edeg := enemyAttackBase
			etype := "physique"
			if ok {
				if ecomp.Degats > 0 {
					edeg = ecomp.Degats
				}
				if ecomp.Type != "" {
					etype = ecomp.Type
				}
			}
			edmg, touche, crit := resolveAttack(&enemy, &player, edeg, etype)
			if !touche {
				fmt.Println("üåÄ L'ennemi rate son attaque !")
			} else {
				player.PV -= edmg
				if player.PV < 0 {
					player.PV = 0
				}
				if crit {
					fmt.Printf("üí• Coup critique ennemi ! Vous subissez %d d√©g√¢ts.\n", edmg)
				} else {
					fmt.Printf("üí• L'ennemi vous inflige %d d√©g√¢ts.\n", edmg)
				}
				if ok {
					// Buff/soin sur soi ‚Üí appliqu√© √† l'ennemi, sinon effet offensif sur le joueur
					if ecomp.Degats <= 0 && ecomp.TypeEffet != "" && isSelfBuff(ecomp.TypeEffet) {
						if eff := CreerEffet(ecomp.TypeEffet, ecomp.Puissance); eff != nil {
							AppliquerEffet(&enemy, *eff)
							fmt.Printf("‚ú® L'ennemi s'applique %s.\n", ecomp.Nom)
						}
					} else if ecomp.TypeEffet != "" {
						maybeApplyEffect(&player, ecomp)
					}
				}
			}
		}

		// Fin de tour: ticks d'effets
		TraiterEffetsFinTour(&player)
		TraiterEffetsFinTour(&enemy)

		if player.PV <= 0 {
			fmt.Println("\nüíÄ D√âFAITE ! Vous avez √©t√© vaincu...")
			fmt.Println("üîÑ Vous retournez au d√©but de la salle.")
			// Persiste les PV du joueur (reste √† 0)
			currentPlayer.PV = player.PV
			playerStats.attackBoost = 0
			return false
		}
	}

	return false
}

// Variante qui force un type d'ennemi si name est non vide
func combatWithAssignedType(currentMap string, isSuper bool, name string) interface{} {
	rand.Seed(time.Now().UnixNano())

	// Joueur
	player := buildPlayerCharacter()

	// Choix de l'ennemi
	var enemy Personnage
	if name == "" {
		enemy = CreateRandomEnemyForMap(currentMap, isSuper)
	} else {
		// Cherche le template par nom √† partir du tier de la salle
		tier := tierForMap(currentMap)
		var pool []EnemyTemplate
		switch tier {
		case TierTutorial:
			pool = tutorialPool
		case TierEarly:
			pool = earlyPool
		case TierMid:
			pool = midPool
		case TierLate:
			pool = latePool
		default:
			pool = earlyPool
		}
		found := false
		for _, t := range pool {
			if t.Name == name {
				enemy = NewEnemyFromTemplate(t, isSuper)
				// Ancien comportement: pas de pr√©fixe de tier, √©ventuellement marqueur super
				if isSuper {
					enemy.Nom = "üíÄ " + enemy.Nom
				}
				found = true
				break
			}
		}
		if !found {
			enemy = CreateRandomEnemyForMap(currentMap, isSuper)
		}
	}

	enemyAttackBase := enemy.ArmeEquipee.DegatsPhysiques
	if enemyAttackBase <= 0 {
		enemyAttackBase = 12
	}

	fmt.Println("\nüó°Ô∏è  COMBAT ENGAG√â ! üó°Ô∏è")
	if isSuper {
		fmt.Printf("Vous affrontez un ENNEMI SURPUISSANT: %s\n", enemy.Nom)
	} else {
		fmt.Printf("Vous affrontez: %s\n", enemy.Nom)
	}

	for player.PV > 0 && enemy.PV > 0 {
		fmt.Printf("\nüíö Vos PV: %d/%d | üíÄ PV Ennemi: %d/%d\n", player.PV, player.PVMax, enemy.PV, enemy.PVMax)
		if playerStats.hasLegendaryWeapon {
			fmt.Println("üåü Excalibur √©quip√©e (+50% d√©g√¢ts de loot)")
		}

		fmt.Println("Actions: [A]ttaquer, [O]bjet, [F]uir")
		fmt.Print("Choisissez une action: ")
		if globalKeyEvents == nil {
			fmt.Println("(clavier non initialis√©)")
			return false
		}
		e := <-globalKeyEvents
		input := strings.ToLower(string(e.Rune))
		if e.Key == keyboard.KeyEsc {
			input = "f"
		}

		AppliquerProtectionsArtefactsDebutTour(&player)

		switch input {
		case "a":
			comp, ok, back := chooseCompetence(&player)
			if back {
				continue
			}
			if !ok {
				comp = Competence{Nom: "Attaque", Degats: 15, Type: "physique"}
			}
			if comp.Degats <= 0 && comp.TypeEffet != "" && isSelfBuff(comp.TypeEffet) {
				if eff := CreerEffet(comp.TypeEffet, comp.Puissance); eff != nil {
					AppliquerEffet(&player, *eff)
				}
			} else if comp.Degats <= 0 && comp.TypeEffet != "" {
				if eff := CreerEffet(comp.TypeEffet, comp.Puissance); eff != nil {
					AppliquerEffet(&enemy, *eff)
				}
			} else {
				degatsBase := comp.Degats
				typeAtk := comp.Type
				if degatsBase <= 0 {
					degatsBase = 15
				}
				if typeAtk == "" {
					typeAtk = "physique"
				}
				dmg, touche, crit := resolveAttack(&player, &enemy, degatsBase, typeAtk)
				if touche {
					enemy.PV -= dmg
					if enemy.PV < 0 {
						enemy.PV = 0
					}
					if crit {
						fmt.Printf("‚öîÔ∏è  Coup critique ! Vous infligez %d d√©g√¢ts.\n", dmg)
					} else {
						fmt.Printf("‚öîÔ∏è  Vous infligez %d d√©g√¢ts.\n", dmg)
					}
					if comp.TypeEffet != "" {
						maybeApplyEffect(&enemy, comp)
					}
				} else {
					fmt.Println("üôÉ Votre attaque rate sa cible !")
				}
			}
		case "o":
			if died := objectMenu(&player, &enemy); died {
				currentPlayer.PV = player.PV
				playerStats.attackBoost = 0
				return false
			}
			if enemy.PV <= 0 {
				fmt.Println("\nüéâ VICTOIRE ! Vous avez vaincu la cr√©ature !")
				playerStats.enemiesKilled++
				coins, jackpot, _ := computeCoinLoot()
				addToInventory("pi√®ces", coins)
				printCoinReward(coins, jackpot)
				tier := tierForMap(currentMap)
				rocks := 0
				switch tier {
				case TierTutorial, TierEarly:
					rocks = 1
				case TierMid:
					rocks = 2
				case TierLate:
					rocks = 3
				}
				if rocks > 0 {
					currentPlayer.Roches += rocks
					fmt.Printf("ü™® Vous obtenez %d roche(s) d'√©volution. Total roches: %d\n", rocks, currentPlayer.Roches)
				}
				currentPlayer.PV = player.PV
				playerStats.attackBoost = 0
				fmt.Println("üí® La cr√©ature dispara√Æt compl√®tement dans un nuage de fum√©e...")
				return "disappear"
			}
			continue
		case "f":
			fmt.Println("üí® Vous fuyez le combat !")
			currentPlayer.PV = player.PV
			playerStats.attackBoost = 0
			return false
		default:
			fmt.Println("Action invalide !")
		}

		TraiterEffetsFinTour(&player)
		TraiterEffetsFinTour(&enemy)

		if enemy.PV <= 0 {
			fmt.Println("\nüéâ VICTOIRE ! Vous avez vaincu la cr√©ature !")
			playerStats.enemiesKilled++
			coins, jackpot, _ := computeCoinLoot()
			addToInventory("pi√®ces", coins)
			printCoinReward(coins, jackpot)
			tier := tierForMap(currentMap)
			rocks := 0
			switch tier {
			case TierTutorial, TierEarly:
				rocks = 1
			case TierMid:
				rocks = 2
			case TierLate:
				rocks = 3
			}
			if rocks > 0 {
				currentPlayer.Roches += rocks
				fmt.Printf("ü™® Vous obtenez %d roche(s) d'√©volution. Total roches: %d\n", rocks, currentPlayer.Roches)
			}
			currentPlayer.PV = player.PV
			playerStats.attackBoost = 0
			fmt.Println("üí® La cr√©ature dispara√Æt compl√®tement dans un nuage de fum√©e...")
			return "disappear"
		}

		if EstEtourdi(&enemy) {
			fmt.Println("üòµ‚Äçüí´ L'ennemi est √©tourdi et rate son tour !")
		} else {
			ecomp, ok := pickRandomCompetence(&enemy)
			edeg := enemyAttackBase
			etype := "physique"
			if ok {
				if ecomp.Degats > 0 {
					edeg = ecomp.Degats
				}
				if ecomp.Type != "" {
					etype = ecomp.Type
				}
			}
			edmg, touche, crit := resolveAttack(&enemy, &player, edeg, etype)
			if !touche {
				fmt.Println("üåÄ L'ennemi rate son attaque !")
			} else {
				player.PV -= edmg
				if player.PV < 0 {
					player.PV = 0
				}
				if crit {
					fmt.Printf("üí• Coup critique ennemi ! Vous subissez %d d√©g√¢ts.\n", edmg)
				} else {
					fmt.Printf("üí• L'ennemi vous inflige %d d√©g√¢ts.\n", edmg)
				}
				if ok {
					if ecomp.Degats <= 0 && ecomp.TypeEffet != "" && isSelfBuff(ecomp.TypeEffet) {
						if eff := CreerEffet(ecomp.TypeEffet, ecomp.Puissance); eff != nil {
							AppliquerEffet(&enemy, *eff)
							fmt.Printf("‚ú® L'ennemi s'applique %s.\n", ecomp.Nom)
						}
					} else if ecomp.TypeEffet != "" {
						maybeApplyEffect(&player, ecomp)
					}
				}
			}
		}

		TraiterEffetsFinTour(&player)
		TraiterEffetsFinTour(&enemy)

		if player.PV <= 0 {
			fmt.Println("\nüíÄ D√âFAITE ! Vous avez √©t√© vaincu...")
			fmt.Println("üîÑ Vous retournez au d√©but de la salle.")
			currentPlayer.PV = player.PV
			playerStats.attackBoost = 0
			return false
		}
	}

	return false
}
